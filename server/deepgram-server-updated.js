const WebSocket = require('ws');
const { createClient } = require('@deepgram/sdk');
const fs = require('fs');
const path = require('path');

// Carregar vari√°veis de ambiente do .env.local
const envPath = path.join(__dirname, '..', '.env.local');
if (fs.existsSync(envPath)) {
  const envContent = fs.readFileSync(envPath, 'utf8');
  envContent.split('\n').forEach(line => {
    if (line.trim() && !line.startsWith('#')) {
      const [key, ...valueParts] = line.split('=');
      if (key && valueParts.length > 0) {
        const value = valueParts.join('=').trim();
        process.env[key.trim()] = value;
      }
    }
  });
}

// Verificar se API Key do Deepgram est√° configurada
const deepgramApiKey = process.env.DEEPGRAM_API_KEY;
if (!deepgramApiKey) {
  console.error('‚ùå DEEPGRAM_API_KEY n√£o encontrada no .env.local');
  console.error('üí° Adicione: DEEPGRAM_API_KEY=sua_nova_api_key');
  process.exit(1);
}

console.log('‚úÖ Nova API Key Deepgram configurada:', deepgramApiKey.substring(0, 8) + '...');

// Criar cliente Deepgram com configura√ß√£o otimizada
let deepgram;
try {
  deepgram = createClient(deepgramApiKey);
  console.log('‚úÖ Cliente Deepgram criado com sucesso');
} catch (error) {
  console.error('‚ùå Erro ao criar cliente Deepgram:', error.message);
  process.exit(1);
}

// Configura√ß√£o do servidor WebSocket
const wss = new WebSocket.Server({ 
  port: 8080,
  perMessageDeflate: false 
});

console.log('üé§ Servidor Deepgram Speech-to-Text (vers√£o atualizada) na porta 8080');

// Configura√ß√£o Deepgram baseada na documenta√ß√£o oficial
const DEEPGRAM_CONFIG = {
  // Configura√ß√µes b√°sicas
  language: 'pt',               // Portugu√™s
  model: 'nova-2',              // Modelo mais recente
  smart_format: true,           // Formata√ß√£o inteligente
  interim_results: true,        // Resultados parciais
  
  // Configura√ß√µes de pontua√ß√£o e formata√ß√£o
  punctuate: true,              // Pontua√ß√£o autom√°tica
  numerals: false,              // N√∫meros como texto
  profanity_filter: false,      // Sem filtro de palavr√µes
  
  // Configura√ß√µes de √°udio
  encoding: 'linear16',         // PCM 16-bit
  sample_rate: 16000,           // 16kHz
  channels: 1,                  // Mono
  
  // Configura√ß√µes de lat√™ncia e finaliza√ß√£o
  endpointing: 300,             // 300ms para finalizar
  utterance_end_ms: 1000,       // 1s de sil√™ncio para utterance
  vad_events: true,             // Eventos de detec√ß√£o de voz
  
  // Configura√ß√µes de alternativas
  alternatives: 1,              // Apenas 1 alternativa
  
  // Configura√ß√µes de velocidade
  no_delay: true,               // Sem delay adicional
  
  // Configura√ß√µes espec√≠ficas para portugu√™s brasileiro
  version: 'latest',            // Vers√£o mais recente
  tier: 'nova',                 // Tier Nova (mais r√°pido)
  
  // Configura√ß√µes de callback (opcional)
  // callback: 'https://seu-webhook.com/callback',
  // callback_method: 'POST',
};

console.log('üîß Configura√ß√£o Deepgram otimizada:', JSON.stringify(DEEPGRAM_CONFIG, null, 2));

// Estat√≠sticas globais
let totalConnections = 0;
let activeConnections = 0;
let totalTranscriptions = 0;
let totalErrors = 0;

// Testar conectividade na inicializa√ß√£o
async function testConnectivity() {
  console.log('üß™ Testando conectividade com nova API key...');
  
  try {
    // Testar endpoint de projetos
    const { result, error } = await deepgram.manage.getProjects();
    
    if (error) {
      console.error('‚ùå Erro de API:', error.message);
      return false;
    }
    
    if (result && result.projects) {
      console.log('‚úÖ Conectividade funcionando!');
      console.log('üìä Projetos encontrados:', result.projects.length);
      return true;
    }
    
    return false;
  } catch (connectError) {
    console.error('‚ùå Erro de conectividade:', connectError.message);
    return false;
  }
}

// Vari√°vel para controlar se a API est√° funcionando
let apiWorking = false;

wss.on('listening', () => {
  console.log('‚úÖ Servidor WebSocket ouvindo na porta 8080');
  console.log('üìã Modo: Speech-to-Text em tempo real');
  console.log('üéØ Endpoint: wss://api.deepgram.com/v1/listen');
});

wss.on('connection', (ws, req) => {
  totalConnections++;
  activeConnections++;
  console.log(`üîó Nova conex√£o WebSocket (${activeConnections} ativas, ${totalConnections} total)`);
  
  let deepgramConnection = null;
  let isTranscriptionActive = false;
  let connectionStartTime = Date.now();
  let lastAudioChunk = Date.now();
  let transcriptionStats = {
    duration: 0,
    interimResults: 0,
    finalResults: 0,
    audioChunks: 0,
    errors: 0
  };

  // Fun√ß√£o para criar conex√£o Deepgram
  function createDeepgramConnection() {
    if (!apiWorking) {
      console.log('‚ö†Ô∏è API n√£o est√° funcionando - transcri√ß√µes n√£o estar√£o dispon√≠veis');
      return null;
    }
    
    try {
      console.log('üöÄ Criando conex√£o live com Deepgram...');
      console.log('üîß Usando configura√ß√£o:', DEEPGRAM_CONFIG);
      
      // Criar conex√£o live com Deepgram
      const dgConnection = deepgram.listen.live(DEEPGRAM_CONFIG);
      
      // Configurar listeners da conex√£o Deepgram
      dgConnection.on('open', () => {
        console.log('‚úÖ Conex√£o Deepgram estabelecida com sucesso');
        ws.send(JSON.stringify({
          type: 'deepgram_connected',
          message: 'Conectado ao Deepgram com sucesso',
          provider: 'deepgram',
          model: DEEPGRAM_CONFIG.model,
          config: DEEPGRAM_CONFIG,
          api_version: 'v1'
        }));
      });

      dgConnection.on('results', (data) => {
        console.log('üì® Resultado recebido do Deepgram');
        
        if (data.channel && data.channel.alternatives && data.channel.alternatives.length > 0) {
          const alternative = data.channel.alternatives[0];
          const transcript = alternative.transcript;
          const confidence = alternative.confidence || 0;
          const isFinal = data.is_final;
          
          // Verificar se √© speech_final para melhor lat√™ncia
          const speechFinal = data.speech_final || false;

          console.log(`üìù Transcri√ß√£o ${isFinal ? 'FINAL' : 'INTERIM'} ${speechFinal ? '(SPEECH_FINAL)' : ''}: "${transcript}" (confian√ßa: ${(confidence * 100).toFixed(1)}%)`);

          if (transcript && transcript.trim()) {
            if (isFinal) {
              transcriptionStats.finalResults++;
              
              ws.send(JSON.stringify({
                type: 'final',
                transcript: transcript,
                confidence: confidence,
                provider: 'deepgram',
                model: DEEPGRAM_CONFIG.model,
                timestamp: Date.now(),
                speech_final: speechFinal,
                api_version: 'v1'
              }));
              
              console.log(`‚úÖ Transcri√ß√£o final enviada: "${transcript}"`);
            } else {
              transcriptionStats.interimResults++;
              
              ws.send(JSON.stringify({
                type: 'interim',
                transcript: transcript,
                confidence: confidence,
                provider: 'deepgram',
                model: DEEPGRAM_CONFIG.model,
                timestamp: Date.now(),
                api_version: 'v1'
              }));
              
              console.log(`üìù Transcri√ß√£o interim enviada: "${transcript}"`);
            }
          } else {
            console.log('‚ö†Ô∏è Transcri√ß√£o vazia recebida do Deepgram');
          }
        } else {
          console.log('‚ö†Ô∏è Estrutura de dados inesperada do Deepgram:', data);
        }
      });

      dgConnection.on('error', (error) => {
        console.error('‚ùå Erro na conex√£o Deepgram:', error);
        transcriptionStats.errors++;
        totalErrors++;
        
        ws.send(JSON.stringify({
          type: 'error',
          message: `Erro Deepgram: ${error.message || 'Erro desconhecido'}`,
          provider: 'deepgram',
          api_version: 'v1'
        }));
      });

      dgConnection.on('close', (closeEvent) => {
        console.log('üîå Conex√£o Deepgram fechada:', closeEvent);
      });

      dgConnection.on('warning', (warning) => {
        console.warn('‚ö†Ô∏è Aviso Deepgram:', warning);
      });

      dgConnection.on('metadata', (metadata) => {
        console.log('üìã Metadata Deepgram:', metadata);
      });

      return dgConnection;
    } catch (error) {
      console.error('‚ùå Erro ao criar conex√£o Deepgram:', error);
      transcriptionStats.errors++;
      totalErrors++;
      
      ws.send(JSON.stringify({
        type: 'error',
        message: `Erro ao conectar: ${error.message}`,
        provider: 'deepgram',
        api_version: 'v1'
      }));
      
      return null;
    }
  }

  // Manipular mensagens do frontend
  ws.on('message', (message) => {
    try {
      const data = JSON.parse(message);
      
      // Log apenas para comandos, n√£o para audio
      if (data.type !== 'audio') {
        console.log('üì® Comando recebido:', data.type);
      }
      
      switch (data.type) {
        case 'start':
          console.log('üéôÔ∏è Iniciando transcri√ß√£o Deepgram');
          
          if (!deepgramConnection) {
            deepgramConnection = createDeepgramConnection();
          }
          
          if (deepgramConnection) {
            isTranscriptionActive = true;
            transcriptionStats.duration = Date.now();
            totalTranscriptions++;
            
            ws.send(JSON.stringify({
              type: 'started',
              message: 'Transcri√ß√£o Deepgram iniciada',
              provider: 'deepgram',
              model: DEEPGRAM_CONFIG.model,
              api_working: apiWorking,
              api_version: 'v1'
            }));
            
            console.log('‚úÖ Transcri√ß√£o iniciada - aguardando √°udio...');
          } else {
            ws.send(JSON.stringify({
              type: 'error',
              message: 'Falha ao conectar com Deepgram - verifique conectividade',
              provider: 'deepgram',
              api_working: apiWorking,
              api_version: 'v1'
            }));
          }
          break;
          
        case 'audio':
          if (deepgramConnection && isTranscriptionActive) {
            try {
              // Converter audio base64 para buffer e enviar para Deepgram
              const audioBuffer = Buffer.from(data.audio, 'base64');
              
              if (audioBuffer.length > 0) {
                deepgramConnection.send(audioBuffer);
                transcriptionStats.audioChunks++;
                lastAudioChunk = Date.now();
                
                // Log ocasional para monitoramento
                if (transcriptionStats.audioChunks % 100 === 0) {
                  console.log(`üìä Chunks de √°udio enviados: ${transcriptionStats.audioChunks}`);
                }
              } else {
                console.warn('‚ö†Ô∏è Chunk de √°udio vazio recebido');
              }
            } catch (error) {
              console.error('‚ùå Erro ao enviar √°udio para Deepgram:', error.message);
              transcriptionStats.errors++;
            }
          } else {
            console.warn('‚ö†Ô∏è √Åudio recebido mas transcri√ß√£o n√£o est√° ativa');
          }
          break;
          
        case 'stop':
          console.log('‚èπÔ∏è Parando transcri√ß√£o Deepgram');
          isTranscriptionActive = false;
          
          if (deepgramConnection) {
            try {
              console.log('üîÑ Finalizando conex√£o Deepgram...');
              deepgramConnection.finish();
            } catch (error) {
              console.error('‚ùå Erro ao finalizar conex√£o Deepgram:', error);
            }
            deepgramConnection = null;
          }
          
          // Calcular dura√ß√£o final
          if (transcriptionStats.duration > 0) {
            transcriptionStats.duration = Date.now() - transcriptionStats.duration;
          }
          
          console.log('üìä Estat√≠sticas da sess√£o:', transcriptionStats);
          
          ws.send(JSON.stringify({
            type: 'stopped',
            message: 'Transcri√ß√£o Deepgram parada',
            provider: 'deepgram',
            stats: transcriptionStats,
            api_working: apiWorking,
            api_version: 'v1'
          }));
          break;

        case 'force-finalize':
          console.log('üéØ Force-finalize solicitado para Deepgram');
          
          if (deepgramConnection && isTranscriptionActive) {
            try {
              ws.send(JSON.stringify({
                type: 'force-finalize-started',
                message: 'Iniciando finaliza√ß√£o for√ßada',
                provider: 'deepgram',
                api_version: 'v1'
              }));

              // Finalizar conex√£o atual e criar nova
              const oldConnection = deepgramConnection;
              
              console.log('üîÑ Finalizando conex√£o atual para force-finalize...');
              oldConnection.finish();
              
              // Aguardar e criar nova conex√£o
              setTimeout(() => {
                console.log('üîÑ Criando nova conex√£o ap√≥s force-finalize...');
                deepgramConnection = createDeepgramConnection();
                
                if (deepgramConnection) {
                  ws.send(JSON.stringify({
                    type: 'force-finalize-completed',
                    message: 'Finaliza√ß√£o for√ßada conclu√≠da, stream reiniciado',
                    provider: 'deepgram',
                    api_version: 'v1'
                  }));
                  console.log('‚úÖ Force-finalize conclu√≠do com sucesso');
                } else {
                  ws.send(JSON.stringify({
                    type: 'force-finalize-error',
                    message: 'Erro ao reiniciar stream ap√≥s finaliza√ß√£o for√ßada',
                    provider: 'deepgram',
                    api_version: 'v1'
                  }));
                  console.error('‚ùå Erro ao reiniciar stream ap√≥s force-finalize');
                }
              }, 500);
              
            } catch (error) {
              console.error('‚ùå Erro no force-finalize:', error);
              ws.send(JSON.stringify({
                type: 'force-finalize-error',
                message: `Erro na finaliza√ß√£o for√ßada: ${error.message}`,
                provider: 'deepgram',
                api_version: 'v1'
              }));
            }
          } else {
            ws.send(JSON.stringify({
              type: 'force-finalize-error',
              message: 'Transcri√ß√£o n√£o est√° ativa',
              provider: 'deepgram',
              api_version: 'v1'
            }));
          }
          break;
      }
    } catch (error) {
      console.error('‚ùå Erro ao processar mensagem:', error);
      transcriptionStats.errors++;
      
      ws.send(JSON.stringify({
        type: 'error',
        message: `Erro ao processar comando: ${error.message}`,
        provider: 'deepgram',
        api_version: 'v1'
      }));
    }
  });

  ws.on('close', () => {
    activeConnections--;
    console.log(`üîå Conex√£o WebSocket fechada (${activeConnections} ativas restantes)`);
    
    // Limpar conex√£o Deepgram se ainda estiver ativa
    if (deepgramConnection) {
      try {
        console.log('üßπ Limpando conex√£o Deepgram...');
        deepgramConnection.finish();
      } catch (error) {
        console.error('‚ùå Erro ao fechar conex√£o Deepgram:', error);
      }
      deepgramConnection = null;
    }
    
    // Log final das estat√≠sticas
    console.log('üìä Estat√≠sticas finais da conex√£o:', transcriptionStats);
  });

  ws.on('error', (error) => {
    console.error('‚ùå Erro na conex√£o WebSocket:', error);
    transcriptionStats.errors++;
  });

  // Enviar confirma√ß√£o de conex√£o
  ws.send(JSON.stringify({
    type: 'connected',
    message: 'Conectado ao servidor Deepgram Speech-to-Text (vers√£o atualizada)',
    provider: 'deepgram',
    model: DEEPGRAM_CONFIG.model,
    config: {
      language: DEEPGRAM_CONFIG.language,
      model: DEEPGRAM_CONFIG.model,
      interim_results: DEEPGRAM_CONFIG.interim_results,
      smart_format: DEEPGRAM_CONFIG.smart_format
    },
    server_info: {
      totalConnections,
      activeConnections,
      api_working: apiWorking,
      api_version: 'v1'
    }
  }));
});

// Tratamento de erros globais
process.on('uncaughtException', (error) => {
  console.error('üí• Erro n√£o tratado:', error.message);
  console.error('üîç Stack trace:', error.stack);
  console.log('üîÑ Servidor continua rodando...');
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('üö® Promise rejeitada:', reason);
  console.error('üîç Promise:', promise);
  console.log('üîÑ Servidor continua rodando...');
});

// Graceful shutdown
process.on('SIGINT', () => {
  console.log('üõë Recebido SIGINT, encerrando servidor...');
  
  // Fechar todas as conex√µes WebSocket
  wss.clients.forEach((ws) => {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'server_shutdown',
        message: 'Servidor sendo encerrado'
      }));
      ws.close();
    }
  });
  
  // Fechar servidor WebSocket
  wss.close(() => {
    console.log('‚úÖ Servidor WebSocket fechado');
    process.exit(0);
  });
});

// Inicializar servidor
(async () => {
  console.log('üéØ Servidor Deepgram Speech-to-Text iniciado');
  console.log('üîß Configura√ß√£o baseada na documenta√ß√£o oficial');
  console.log('üìö Documenta√ß√£o: https://developers.deepgram.com/reference/listen-live');
  
  // Testar conectividade
  apiWorking = await testConnectivity();
  
  if (apiWorking) {
    console.log('‚úÖ API funcionando! Servidor pronto para transcri√ß√µes em tempo real');
  } else {
    console.log('‚ö†Ô∏è API n√£o est√° acess√≠vel - servidor funcionar√° sem transcri√ß√µes');
    console.log('üí° Verifique conectividade de rede e firewall');
  }
})(); 